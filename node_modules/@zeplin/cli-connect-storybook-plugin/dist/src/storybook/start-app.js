"use strict";
// Original file: https://github.com/chromaui/chromatic-cli/blob/a5cb862/bin/storybook/start-app.js
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startApp = exports.checkResponse = void 0;
const cross_spawn_1 = require("cross-spawn");
const https_1 = __importDefault(require("https"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const path_1 = __importDefault(require("path"));
const logger_1 = require("../util/logger");
const POLL_INTERVAL = 1000;
const TIMEOUT = 5 * 60 * 1000;
const PROMPT_TIMEOUT = 20 * 1000;
const httpsAgent = new https_1.default.Agent({ rejectUnauthorized: false });
function checkResponse(url) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const response = yield node_fetch_1.default(url, { agent: url.startsWith('https:') ? httpsAgent : undefined });
            return response.ok;
        }
        catch (e) {
            return false;
        }
    });
}
exports.checkResponse = checkResponse;
function waitForResponse(child, url) {
    return __awaiter(this, void 0, void 0, function* () {
        const logger = logger_1.getLogger();
        logger.info("Waiting Storybook to start…");
        const timeoutAt = Date.now() + TIMEOUT;
        let promptAt = Date.now() + PROMPT_TIMEOUT;
        return new Promise((resolve, reject) => {
            let resolved = false;
            function check() {
                return __awaiter(this, void 0, void 0, function* () {
                    if (Date.now() > timeoutAt) {
                        resolved = true;
                        reject(new Error(`No server responding at ${url} within ${TIMEOUT / 1000} seconds.`));
                        return;
                    }
                    if (Date.now() > promptAt) {
                        logger.warn(`No server responding at ${url}, waiting for Storybook to start…`);
                        promptAt = Date.now() + PROMPT_TIMEOUT;
                    }
                    if (yield checkResponse(url)) {
                        resolved = true;
                        resolve();
                        return;
                    }
                    setTimeout(check, POLL_INTERVAL);
                });
            }
            check();
            if (child) {
                let storybookOutput = '';
                child.stderr.on('data', e => {
                    logger.debug(`storybook - [sterr] - ${e.toString()}`);
                    storybookOutput += e.toString();
                });
                child.stdout.on('data', o => {
                    logger.debug(`storybook - [stdout] - ${o.toString()}`);
                    storybookOutput += o.toString();
                });
                child.on('close', () => {
                    if (!resolved) {
                        reject(new Error(`Storybook script to start: ${storybookOutput}\n`));
                    }
                });
            }
        });
    });
}
function startApp({ scriptName, commandName, args, url, inheritStdio }) {
    return __awaiter(this, void 0, void 0, function* () {
        const env = Object.assign(Object.assign({}, process.env), { NODE_ENV: 'development', BROWSER: 'none' });
        let child;
        if (scriptName) {
            if (yield checkResponse(url)) {
                // We assume the process that is already running on the url is indeed our Storybook
                return null;
            }
            // This technique lifted from https://github.com/mysticatea/npm-run-all/blob/52eaf86242ba408dedd015f53ca7ca368f25a026/lib/run-task.js#L156-L174
            const npmPath = typeof process.env.npm_execpath === 'string' ?
                // Replace npx-cli.js with npm-cli.js
                // hacky but resolves the problem until we can refactor this file
                // https://github.com/zeplin/cli-connect-storybook-plugin/issues/38
                process.env.npm_execpath.replace("npx-cli.js", "npm-cli.js")
                : undefined;
            const npmPathIsJs = typeof npmPath === 'string' && /\.m?js/.test(path_1.default.extname(npmPath));
            const isYarn = typeof npmPath === 'string' && /^yarn(\.js)?$/.test(path_1.default.basename(npmPath));
            const execPath = npmPathIsJs ? process.execPath : npmPath || 'npm';
            const params = [
                ...(npmPathIsJs ? [npmPath] : []),
                'run',
                scriptName,
                ...(isYarn ? [] : ["--"]),
                ...args
            ];
            logger_1.getLogger().debug(`Running script: ${execPath} ${params.join(" ")}`);
            // Run either:
            //   npm/yarn run scriptName (depending on npm_execpath)
            //   node path/to/npm.js run scriptName (if npm run via node)
            child = cross_spawn_1.spawn(execPath, params, Object.assign({ env, cwd: process.cwd() }, (inheritStdio && { stdio: 'inherit' })));
        }
        else {
            if (!commandName) {
                throw new Error('You must pass commandName or scriptName');
            }
            logger_1.getLogger().debug(`Running command: ${commandName}`);
            child = cross_spawn_1.spawn(commandName, { env, shell: true });
        }
        if (url) {
            yield waitForResponse(child, url);
        }
        return child;
    });
}
exports.startApp = startApp;
//# sourceMappingURL=start-app.js.map