"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthenticationService = exports.AUTH_METHOD = void 0;
const chalk_1 = __importDefault(require("chalk"));
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const inquirer_1 = __importDefault(require("inquirer"));
const open_1 = __importDefault(require("open"));
const url_1 = require("url");
const api_1 = require("../api");
const errors_1 = require("../errors");
const authFileUtil = __importStar(require("../util/auth-file"));
const envUtil = __importStar(require("../util/env"));
const logger_1 = __importDefault(require("../util/logger"));
const server_1 = require("../server");
const defaults_1 = require("../config/defaults");
const error_1 = require("../util/error");
function notEmptyValidator(errorMessage) {
    return (input) => (input && input.length > 0 ? true : errorMessage);
}
const validate = (authentication, requiredScopes) => {
    if (!authentication || !authentication.token) {
        throw new errors_1.AuthError("No authentication token is found.");
    }
    const decodedToken = jsonwebtoken_1.default.decode(authentication.token, { complete: false });
    if (!decodedToken) {
        throw new errors_1.AuthError("Invalid authentication token.");
    }
    const [, userId] = (decodedToken.aud || "").split(":");
    if (!userId) {
        throw new errors_1.AuthError("Audience is not set in authentication token.");
    }
    if (!requiredScopes) {
        return authentication;
    }
    const scopes = decodeURI((decodedToken.scope || "")).split(" ");
    const missingScopes = requiredScopes.filter(scope => !scopes.includes(scope));
    if (missingScopes.length > 0) {
        logger_1.default.debug(`Missing ${missingScopes.join(", ")} scope${missingScopes.length === 1 ? "" : "s"} in authentication token.`);
        throw new errors_1.AuthError("Access token has missing privileges, please login again to re-create access token.");
    }
    return authentication;
};
var AUTH_METHOD;
(function (AUTH_METHOD) {
    AUTH_METHOD[AUTH_METHOD["ENVIRONMENT_VARIABLE"] = 0] = "ENVIRONMENT_VARIABLE";
    AUTH_METHOD[AUTH_METHOD["LOCAL_AUTH_FILE"] = 1] = "LOCAL_AUTH_FILE";
    AUTH_METHOD[AUTH_METHOD["LOGIN_WITH_PROMPT"] = 2] = "LOGIN_WITH_PROMPT";
    AUTH_METHOD[AUTH_METHOD["LOGIN_WITH_BROWSER"] = 3] = "LOGIN_WITH_BROWSER";
    AUTH_METHOD[AUTH_METHOD["UNKNOWN"] = 4] = "UNKNOWN";
})(AUTH_METHOD = exports.AUTH_METHOD || (exports.AUTH_METHOD = {}));
class AuthenticationService {
    constructor(authentication) {
        this.zeplinApi = new api_1.ZeplinApi();
        this.loginServer = new server_1.LoginServer(defaults_1.defaults.app.authRedirectPath);
        this.authentication = authentication;
    }
    authenticate({ requiredScopes = [], noBrowser = false } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.authentication) {
                return this.authentication;
            }
            if (!this.authentication) {
                const tokenFromEnv = envUtil.getAccessTokenFromEnv();
                if (tokenFromEnv) {
                    logger_1.default.debug(`Found access token from ZEPLIN_ACCESS_TOKEN env var. value: ${tokenFromEnv}`);
                    this.authentication = {
                        token: tokenFromEnv,
                        method: AUTH_METHOD.ENVIRONMENT_VARIABLE
                    };
                }
                else if (!envUtil.isCI()) {
                    const tokenFromFile = yield authFileUtil.readAuthToken();
                    if (tokenFromFile) {
                        logger_1.default.debug(`Found access token from auth file. value: ${tokenFromFile}`);
                        this.authentication = {
                            token: tokenFromFile,
                            method: AUTH_METHOD.LOCAL_AUTH_FILE
                        };
                    }
                    else {
                        logger_1.default.info(`Access token not found in ${chalk_1.default.dim `ZEPLIN_ACCESS_TOKEN`} environment variable.`);
                        this.authentication = yield this.promptForLogin({ noBrowser });
                    }
                }
            }
            return validate(this.authentication, requiredScopes);
        });
    }
    validateToken({ requiredScopes = [] } = {}) {
        return validate(this.authentication, requiredScopes);
    }
    revokeToken() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.authentication) {
                logger_1.default.debug("Revoking existing auth token");
                try {
                    yield this.zeplinApi.revokeToken(this.authentication.token);
                }
                catch (err) {
                    if (!error_1.isAuthenticationError(err)) {
                        throw err;
                    }
                }
            }
        });
    }
    promptForLogin({ requiredScopes = [], ignoreSaveTokenErrors = true, noBrowser = false, forceRenewal = false } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (forceRenewal && this.authentication) {
                yield this.revokeToken();
            }
            logger_1.default.info("\nLogin into Zeplinâ€¦");
            if (!noBrowser) {
                this.authentication = yield this.promptForBrowserLogin();
                if (!this.authentication.token) {
                    logger_1.default.info("Login via browser is failed. Please type in your Zeplin credentials to login.");
                    this.authentication = yield this.promptForCLILogin();
                }
            }
            else {
                this.authentication = yield this.promptForCLILogin();
            }
            validate(this.authentication, requiredScopes);
            try {
                yield authFileUtil.saveAuthToken(this.authentication.token);
            }
            catch (err) {
                logger_1.default.debug(`${err.stack}`);
                if (!ignoreSaveTokenErrors) {
                    throw err;
                }
            }
            return this.authentication;
        });
    }
    promptForBrowserLogin() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const authUrl = new url_1.URL("/oauth/authorize", defaults_1.defaults.app.webURL);
            authUrl.searchParams.append("client_id", defaults_1.defaults.api.clientId);
            authUrl.searchParams.append("scope", "read write delete");
            authUrl.searchParams.append("redirect_uri", defaults_1.defaults.app.webAuthRedirectURL);
            yield open_1.default(authUrl.toString());
            const prompt = inquirer_1.default.prompt([{
                    type: "input",
                    name: "token",
                    message: "Paste your access token here",
                    validate: notEmptyValidator("Please enter your access token.")
                }]);
            /**
             * Zeplin should redirect to local login server with authorization token;
             * however, if redirection fails user should be able to paste the token from their browser.
             *
             * Since we don't know which will happen first, we race the promises for both conditions.
             */
            const accessToken = yield Promise.race([
                // Run auth server
                this.loginServer.waitForToken({ port: defaults_1.defaults.commands.login.port })
                    .then(token => token)
                    .catch(err => {
                    logger_1.default.error(err.message);
                    this.loginServer.stop();
                }),
                // Wait for paste prompt
                prompt
                    .then((answer) => answer.token)
                    .catch(err => { logger_1.default.error(err.message); })
            ]);
            // Cleanup
            yield this.loginServer.stop();
            try {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                (_a = prompt.ui) === null || _a === void 0 ? void 0 : _a.close();
            }
            catch (_) {
                // Ignore
            }
            const token = accessToken;
            return {
                token,
                method: AUTH_METHOD.LOGIN_WITH_BROWSER
            };
        });
    }
    promptForCLILogin() {
        return __awaiter(this, void 0, void 0, function* () {
            const credentials = yield inquirer_1.default.prompt([
                {
                    type: "input",
                    name: "handle",
                    message: "Username/Email",
                    validate: notEmptyValidator("Please enter your username or email.")
                },
                {
                    type: "password",
                    name: "password",
                    message: "Password",
                    validate: notEmptyValidator("Please enter your password.")
                }
            ]);
            const loginResponse = yield this.zeplinApi.login(Object.assign({}, credentials));
            const token = yield this.zeplinApi.generateToken(loginResponse.token);
            return {
                token,
                method: AUTH_METHOD.LOGIN_WITH_PROMPT
            };
        });
    }
}
exports.AuthenticationService = AuthenticationService;
