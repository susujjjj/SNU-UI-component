"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.connectComponentConfigFiles = void 0;
const chalk_1 = __importDefault(require("chalk"));
const ts_dedent_1 = __importDefault(require("ts-dedent"));
const import_from_1 = __importDefault(require("import-from"));
const path_1 = __importDefault(require("path"));
const url_join_1 = __importDefault(require("url-join"));
const errors_1 = require("../../errors");
const defaults_1 = require("../../config/defaults");
const logger_1 = __importDefault(require("../../util/logger"));
const package_1 = require("../../util/package");
const text_1 = require("../../util/text");
const ALLOWED_LINK_TYPES = [
    "styleguidist" /* styleguidist */,
    "storybook" /* storybook */,
    "github" /* github */,
    "custom" /* custom */
];
const importPlugin = (pluginName) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        // Workaround to retrieve plugins for initializer
        const pluginInCwd = import_from_1.default.silent("node_modules", pluginName);
        if (pluginInCwd) {
            return pluginInCwd.default;
        }
        return (yield Promise.resolve().then(() => __importStar(require(pluginName)))).default;
    }
    catch (e) {
        const error = new errors_1.CLIError(ts_dedent_1.default `
            Could not find plugin ${chalk_1.default.bold(pluginName)} failed.
            Please make sure that it's ${package_1.isRunningFromGlobal() ? "globally " : ""}installed and try again.
                ${text_1.getInstallCommand(pluginName)}
        `);
        error.stack = e.stack;
        throw error;
    }
});
const createPluginInstance = (plugin, components) => __awaiter(void 0, void 0, void 0, function* () {
    const PluginClass = yield importPlugin(plugin.name);
    const pluginInstance = new PluginClass();
    logger_1.default.debug(`Initializing ${plugin.name}.`);
    // Check that plugin implements the required functions
    if (!(typeof pluginInstance.process === "function") ||
        !(typeof pluginInstance.supports === "function")) {
        throw new errors_1.CLIError(ts_dedent_1.default `
                ${chalk_1.default.bold(plugin.name)} does not conform Connected Components plugin interface.
                Please make sure that the plugin implements the requirements listed on the documentation.
                https://github.com/zeplin/cli/blob/master/PLUGIN.md
        `);
    }
    pluginInstance.name = plugin.name;
    if (typeof pluginInstance.init === "function") {
        logger_1.default.debug(`${plugin.name} has init method. Initializing with ${JSON.stringify(plugin.config)}`);
        yield pluginInstance.init({ config: plugin.config, components, logger: logger_1.default });
    }
    return pluginInstance;
});
const initializePlugins = (plugins, components) => __awaiter(void 0, void 0, void 0, function* () {
    const imports = plugins.map(plugin => createPluginInstance(plugin, components));
    const pluginInstances = yield Promise.all(imports);
    return pluginInstances;
});
const convertToData = (plugin, componentData) => {
    const copyComponentData = Object.assign({}, componentData);
    if (typeof copyComponentData.description === "undefined" || copyComponentData.description.trim() === "") {
        delete copyComponentData.description;
    }
    if (typeof copyComponentData.snippet === "undefined" || copyComponentData.snippet.trim() === "") {
        delete copyComponentData.snippet;
        delete copyComponentData.lang;
    }
    delete copyComponentData.links;
    return Object.assign({ plugin }, copyComponentData);
};
const processLink = (link) => {
    if (!ALLOWED_LINK_TYPES.includes(link.type)) {
        link.type = "custom" /* custom */;
    }
    link.url = encodeURI(link.url);
    return link;
};
const createRepoLink = (componentPath, gitConfig, repoDefaults) => {
    const url = gitConfig.url || repoDefaults.url;
    const { repository } = gitConfig;
    const branch = gitConfig.branch || repoDefaults.branch;
    const basePath = gitConfig.path || "";
    const prefix = repoDefaults.prefix || "";
    const filePath = componentPath.split(path_1.default.sep);
    return {
        type: repoDefaults.type,
        url: encodeURI(url_join_1.default(url, repository, prefix, branch, basePath, ...filePath))
    };
};
const createBitbucketLink = (componentPath, bitbucketConfig) => {
    const { url = defaults_1.defaults.bitbucket.url, repository, branch = "", project = "", user = "", path: basePath = "" } = bitbucketConfig;
    const isCloud = url === defaults_1.defaults.bitbucket.url;
    const filePath = componentPath.split(path_1.default.sep);
    let preparedUrl;
    if (isCloud) {
        const prefix = defaults_1.defaults.bitbucket.cloudPrefix;
        preparedUrl = url_join_1.default(url, user, repository, prefix, branch, basePath, ...filePath);
    }
    else if (!project && !user) {
        // Backward compatibility
        // TODO: remove this block after a while
        preparedUrl = url_join_1.default(url, repository, branch, basePath, ...filePath);
    }
    else {
        const owner = project
            ? { path: "projects", name: project }
            : { path: "users", name: user };
        preparedUrl = url_join_1.default(url, owner.path, owner.name, "repos", repository, "browse", basePath, ...filePath);
        if (branch) {
            preparedUrl += `?at=${branch}`;
        }
    }
    return {
        type: defaults_1.defaults.bitbucket.type,
        url: encodeURI(preparedUrl)
    };
};
const createRepoLinks = (componentPath, componentConfigFile) => {
    const repoLinks = [];
    if (componentConfigFile.github) {
        repoLinks.push(createRepoLink(componentPath, componentConfigFile.github, defaults_1.defaults.github));
    }
    if (componentConfigFile.gitlab) {
        repoLinks.push(createRepoLink(componentPath, componentConfigFile.gitlab, defaults_1.defaults.gitlab));
    }
    if (componentConfigFile.bitbucket) {
        repoLinks.push(createBitbucketLink(componentPath, componentConfigFile.bitbucket));
    }
    return repoLinks;
};
const connectComponentConfig = (component, componentConfigFile, plugins) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const data = [];
    const urlPaths = [];
    // Execute all plugins
    const pluginPromises = plugins.map((plugin) => __awaiter(void 0, void 0, void 0, function* () {
        var _b;
        try {
            if (plugin.supports(component)) {
                logger_1.default.debug(`${plugin.name} supports ${component.path}. Processingâ€¦`);
                const componentData = yield plugin.process(component);
                data.push(convertToData(plugin.name, componentData));
                (_b = componentData.links) === null || _b === void 0 ? void 0 : _b.forEach(link => urlPaths.push(processLink(link)));
                logger_1.default.debug(`${plugin.name} processed ${component.path}: ${componentData}`);
            }
            else {
                logger_1.default.debug(`${plugin.name} does not support ${component.path}.`);
            }
        }
        catch (err) {
            throw new errors_1.CLIError(ts_dedent_1.default `
                Error occurred while processing ${chalk_1.default.bold(component.path)} with ${chalk_1.default.bold(plugin.name)}:

                ${err.message}
            `, err.stack);
        }
    }));
    yield Promise.all(pluginPromises);
    (_a = componentConfigFile.links) === null || _a === void 0 ? void 0 : _a.forEach(link => {
        const { name, type, url } = link;
        // TODO: remove styleguidist specific configuration from CLI core
        if (type === "styleguidist" && component.styleguidist) {
            const encodedKind = encodeURIComponent(component.styleguidist.name);
            urlPaths.push({ name, type: "styleguidist" /* styleguidist */, url: url_join_1.default(url, `#${encodedKind}`) });
        }
        else if (component[type]) {
            const customUrlPath = component[type].urlPath;
            if (customUrlPath) {
                urlPaths.push({ name, type: "custom" /* custom */, url: url_join_1.default(url, customUrlPath) });
            }
        }
    });
    urlPaths.push(...createRepoLinks(component.path, componentConfigFile));
    return {
        path: component.path,
        name: component.name,
        zeplinNames: component.zeplinNames,
        zeplinIds: component.zeplinIds,
        urlPaths,
        data
    };
});
const connectComponentConfigFile = (componentConfigFile) => __awaiter(void 0, void 0, void 0, function* () {
    const { components } = componentConfigFile;
    const plugins = yield initializePlugins(componentConfigFile.plugins || [], components);
    const connectedComponents = yield Promise.all(components.map(component => connectComponentConfig(component, componentConfigFile, plugins)));
    return {
        projects: componentConfigFile.projects || [],
        styleguides: componentConfigFile.styleguides || [],
        connectedComponents
    };
});
const connectComponentConfigFiles = (componentConfigFiles) => {
    const promises = componentConfigFiles.map(componentConfigFile => connectComponentConfigFile(componentConfigFile));
    return Promise.all(promises);
};
exports.connectComponentConfigFiles = connectComponentConfigFiles;
