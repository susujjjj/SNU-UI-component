"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Task = void 0;
const chalk_1 = __importDefault(require("chalk"));
const log_symbols_1 = __importDefault(require("log-symbols"));
const ora_1 = __importDefault(require("ora"));
const text_1 = require("../text");
const types_1 = require("./types");
const error_1 = require("./error");
function renderUI(context, ui) {
    const msg = typeof ui === "function" ? ui(context) : ui;
    if (typeof msg === "string") {
        return { text: msg };
    }
    else if (typeof msg === "object") {
        const { text, subtext } = msg;
        const t = typeof text === "function" ? text(context) : text;
        const st = typeof subtext === "function" ? subtext(context) : subtext;
        return { text: t, subtext: st };
    }
    return {};
}
const defaultSkipFn = () => false;
const defaultErrorHandler = (err) => {
    const error = error_1.TaskError.isTaskError(err) ? (err.cause || err) : err;
    throw error;
};
function formatUI(renderedUI) {
    const { text, subtext } = renderedUI || {};
    return subtext ? `${text}\n${chalk_1.default.dim(text_1.indent(subtext, "   â†’ "))}` : text;
}
function wrapStepsIntoTask(steps) {
    return (ctx, task) => __awaiter(this, void 0, void 0, function* () {
        for (const step of steps) {
            if (task.isPending()) {
                // eslint-disable-next-line no-await-in-loop
                const result = yield step(ctx, task);
                if (result) {
                    task.render(ctx, result);
                }
            }
        }
        return ctx;
    });
}
class Task {
    constructor(params) {
        this.state = types_1.State.PENDING;
        this.steps = params.steps || [];
        this.ui = params.initial || "Running task...";
        this.skipFn = params.skip || defaultSkipFn;
        this.spinner = ora_1.default(params.spinnerOptions);
        this.errorHandler = params.errorHandler || defaultErrorHandler;
    }
    isPending() {
        return this.state === types_1.State.PENDING;
    }
    isCompleted() {
        return this.state === types_1.State.COMPLETED;
    }
    isFailed() {
        return this.state === types_1.State.FAILED;
    }
    isSkipped() {
        return this.state === types_1.State.SKIPPED;
    }
    renderUIText(context, ui) {
        const renderedUI = renderUI(context, ui);
        if (renderedUI.text) {
            this.ui = ui;
            this.renderedUI = renderedUI;
        }
        else if (renderedUI.subtext && this.renderedUI) {
            this.renderedUI.subtext = renderedUI.subtext;
        }
        return formatUI(this.renderedUI);
    }
    /**
     * Update UI.
     *
     * Does not change current state of the task.
     *
     * @param {T} context Task context
     * @param {TaskUITypes<T>} ui New UI
     * @returns {void}
     */
    render(context, ui) {
        const msg = this.renderUIText(context, ui);
        if (msg) {
            this.spinner.text = msg;
            this.spinner.render();
        }
    }
    /**
     * Stops the spinner and changes it with skip symbol and persists
     *
     * Changes current state to SKIPPED.
     *
     * @param {T} context Task context
     * @param {TaskUITypes<T>} ui Persists this UI if provided.
     * @returns {void}
     */
    skip(context, ui) {
        this.state = types_1.State.SKIPPED;
        this.spinner.info(this.renderUIText(context, ui));
    }
    /**
     * Stops the spinner and changes it with failure symbol and persists
     *
     * Changes current state to FAILED.
     *
     * @param {T} context Task context
     * @param {TaskUITypes<T>} ui Persists this UI if provided.
     * @returns {void}
     */
    fail(context, ui) {
        this.state = types_1.State.FAILED;
        this.spinner.fail(this.renderUIText(context, ui));
    }
    /**
     * Stops the spinner and changes it with succeed symbol and persists
     *
     * Changes current state to COMPLETED.
     *
     * @param {T} context Task context
     * @param {TaskUITypes<T>} ui Persists this UI if provided.
     * @returns {void}
     */
    complete(context, ui) {
        this.state = types_1.State.COMPLETED;
        this.spinner.succeed(this.renderUIText(context, ui));
    }
    isSpinning() {
        return this.spinner.isSpinning;
    }
    /**
     * Starts the spinner.
     *
     * No effect if the spinner is already started.
     *
     * Does not change current state of the task.
     *
     * @param {T} context Task context
     * @param {TaskUITypes<T>} ui Persists this UI if provided.
     * @returns {void}
     */
    startSpinner(context, ui) {
        if (!this.spinner.isSpinning) {
            this.spinner.start(this.renderUIText(context, ui));
        }
    }
    /**
     * Stops the spinner.
     *
     * Persists the given UI or clears the current spinner.
     * No effect if the spinner is already stopped.
     *
     * Does not change current state of the task.
     *
     * @param {T} context Task context
     * @param {TaskUITypes<T>} ui Persists this UI if provided.
     * @returns {void}
     */
    stopSpinner(context, ui) {
        if (this.spinner.isSpinning) {
            if (ui) {
                this.spinner.stopAndPersist({
                    symbol: log_symbols_1.default.info,
                    text: this.renderUIText(context, ui)
                });
            }
            else {
                this.spinner.stop();
                this.spinner.clear();
            }
        }
    }
    /**
     * Clears current task spinner
     *
     * @returns {void}
     */
    clearSpinner() {
        this.spinner.clear();
    }
    /**
     * Returns the current rendered text.
     *
     * @returns {String} Rendered text
     */
    getCurrentText() {
        return this.spinner.text;
    }
    run(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const ctx = context || Object.create(null);
            try {
                this.startSpinner(ctx, this.ui);
                const skipped = yield this.skipFn(ctx);
                if (skipped) {
                    if (typeof skipped === "boolean") {
                        this.skip(ctx);
                    }
                    else {
                        this.skip(ctx, skipped);
                    }
                }
                if (!this.isSkipped()) {
                    const task = wrapStepsIntoTask(this.steps);
                    yield task(ctx, this);
                    if (this.isPending()) {
                        this.complete(ctx);
                    }
                }
                return ctx;
            }
            catch (e) {
                if (error_1.TaskError.isTaskError(e)) {
                    e.message = this.renderUIText(ctx, e.ui) || e.message;
                }
                this.fail(ctx, e.ui);
                this.errorHandler(e, ctx, this);
                return ctx;
            }
        });
    }
}
exports.Task = Task;
